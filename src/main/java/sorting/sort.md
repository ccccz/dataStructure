# 排序

# 插入排序

## 插入排序
### 基本思想
插入排序由N-1次排序组成，对于第p=1到p=N-1次排序，保证从位置0到p的元素已排序
### 算法分析
比较次数KCN： O(n^2)

交换次数RMN： O(n^2)

稳定性： 稳定

## 二分插入排序
### 基本思想
与插入排序类似，只是在将新元素插入时采用二分查找
### 算法分析
比较次数KCN： O(n*log2n)

交换次数RMN： O(n^2)

稳定性： 稳定

## 希尔排序
### 基本思想
又称为缩小增量排序。
### 算法分析
均为n^1.3左右

稳定性： 不稳定

# 交换排序

## 冒泡排序
### 基本思想
不太懂fx的想法，不过只是冒泡的话就是一直交换
可以设计一个交换标记，如果一个内循环中没有出现交换，则排序完成
### 算法分析
KCN：max O(n^2)    min O(n)

RMN: max O(n^2)    min O(0)    avg O(n^2)

稳定性： 稳定的

## 快速排序
### 基本思想
分治思想，集体实现思路看代码
### 算法分析
时间代价：  最差 Θ(n^2)    最佳 Θ(nlogn)     平均 Θ(nlogn)

空间代价：  最差 Θ(n)    最佳 Θ(logn)     平均 Θ(logn)

稳定性： 不稳定

# 选择排序
## 直接选择排序
### 基本思想
最自然的排序想法，就是依次找出第一小的，放到第一个位置上，然后找第二小的，第三小的，放到第二，三个位置上，直至全部排序
### 算法分析
KCN： Θ(n^2)

RMN： n-1

稳定性： 不稳定

## 锦标赛排序
//TODO: 锦标赛排序

## 堆排序
### 基本算法
基于最大堆的排序，先创建最大堆，然后依次取出堆顶元素
### 算法分析
建堆： Θ(n)

删除堆顶： Θ(logn)

总时间： Θ(nlogn)

空间代价： 1
> Q：为什么不计算堆所占的空间

# 归并排序
## 归并排序
### 基本思想
分治思想

将数组不断划分，进行排序后合并到一起
### 算法分析
//TODO: 归并排序的算法分析

# 基数排序
## 桶排序

## 多关键码排序
### 基本思想
